#  다이나믹 프로그래밍

> 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘

* 컴퓨터를 활용해서 해결하기 어려운 문제 -> 최적의 해를 구하기에 시간이 매우 많이 팔요하거나 메모리 공간이 매우 많이 필요한 문제
* 이러한 문제를 해결하기 위해서는 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야 한다.
* 다만, 어떤 문제는 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법이 있다. 대표적이 방법이 다이나믹 프로그래밍 기법이다. 
* 다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시 -> 피보나치 수열

* 피보나치 수열

  * 이전 두 항의 합을 현재의 항으로 설정하는 수열
  * a(n) = a(n-1) + a(n-2), a(1) = 1, a(2) = 1
  * 프로그래밍에서는 이러한 수열을 배열이나 리스트로 표현할 수 있다. 
    * 수열 자체가 여러 개의 수가 규칙에 따라서 배열된 형태를 의미
    * 파이썬에서는 리스트 자료형, C/C++와 자바에서는 배열을 이용해서 이를 처리한다. 
      * 파이썬의 경우 기본 자료형인 리스트 자료형이 연결 리스트의 기능을 포함하고 있다는 점이 다른 프로그래밍 언어에서의 배열과 차이점이다.

  ```python
  # 재귀 함수를 사용한 피보나치 함수 소스코드
  
  def fibo(x):
      if x == 1 or x == 2:
          return 1
      return fibo(x - 1) + fibo(x - 2)
  
  print(fibo(4))
  ```

  * 그런데 피보나치 수열의 소스코드를 이렇게 작성하면 f(n)함수에서 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어난다. 시간 복잡도가 O(2^N)

  * f(n) 에서 n이 커지면 커질수록 반복해서 호출하는 수가 많아진다.

  * 이러한 피보나치 함수는 다이나믹 프로그래밍 사용하면 효과적으로 해결할 수 있다.

  * 다이나믹 프로그래밍을 사용하기 위해서는 다음 조건을 만족해야 한다.

    1. 큰 문제를 작은 문제로 나눌 수 있다.
    2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

  * 피보나치 수열은 이러한 조건을 만족하는 대표 문제이다. 메모이제이션 기법을 사용해서 해결할 수 있다.

  * 메모이제이션 

    * 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한 번 구한 결과를 메모리 공간에 메모해두고 같을 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법. 값을 저장하는 방법이므로 캐싱 이라고도 한다.

    * 메모이제이션을 구현하는 방법 
      * 한 번 구한 정보를 리스트에 저장한다
      * 다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때는 이미 구한 정답을 그대로 리스트에서 가져온다.

  ```python
  # 메모이제이션을 사용한 피보나치 함수 소스코드
  
  # 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
  d = [0] * 100
  
  # 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
  def fibo(x):
      # 종료 조건(1 혹은 2일 때 1을 반환)
      if x == 1 or x == 2:
          return 1
      # 이미 계산한 적 있는 문제라면 그대로 반환
      if d[x] != 0:
          return d[x]
      # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
      d[x] = fibo(x - 1) + fibo(x - 2)
      return d[x]
  
  print(fibo(99))
  ```

* 정리하자면, 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다.

* 다이나믹 프로그래밍과 분할 정복의 차이점은 다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있다는 점이다.

  * 퀵 정렬을 예로 들면, 한 번 기준 원소(pivot)가 자리를 변경해서 자리를 잡게 되면 그 기준 원소의 위치는 더 이상 바뀌지 않고 그 피벗값을 다시 처리하는 부분 문제는 존재하지 않는다.
  * 반면, 다이나믹 프로그래밍은 한 번 해결했던 문제를 다시금 해결한다는 점이 특징이다. 그렇기 때문에 이미 해결된 부분 문제에 대한 답을 저장해 놓고, 이 문제는 이미 해결이 됐던 것이니까 다시 해결할 필요가 없다고 반환하는 것이다. 

  * 다이나믹 프로그래밍을 적용했을 때의 피보나치 수열 알고리즘의 시간 복잡도는 O(N)

* 탑다운 방식

  * 하향식 방식
  * 재귀함수를 이요하여 다이나믹 프로그래밍 소스코드를 작성하는 방법
  * 큰 문제를 해결하기 위해 작은 문제를 호출한다고 해서 탑다운 방식이라고 함
  * 메모이제이션 방식을 사용

* 보텀업 방식

  * 상향식 방식

  * 다이나믹 프로그래밍의 전형적인 형태

  * 단순히 반복문을 이용하여 소스코드를 작성하는 경우

  * 작은 문제부터 차근차근 답을 도출한다고 하여 보텀업 방식이라고 함

  * 보텀업 방식에서 사용되는 결과 저장용 리스트를 'DP 테이블' 이라고 부른다.

  * 피보나치 수열 문제를 보텀업 방식으로 푼 소스코드

    ```python
    # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
    d = [0]*100
    
    # 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
    d[1] = 1
    d[2] = 1
    n = 99
    
    # 피보나치 함수 반복문으로 구현(보텀업 다이나믹 프로그래밍)
    for i in range(3, n+1)
    	d[i] = d[i-1] + d[i-2]
        
    print(d[n])
    ```



* 문제 풀 때 다이나믹 프로그래밍 활용
  * 특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인하자
  * 일단 단순히 재귀함수로 비효율적인 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 즉 메모이제이션을 사용할 수 있으면 코드를 개선하는 것도 좋은 아이디어
  * 가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 보텀업 방식으로 구현하는 것을 권장. 시스템상 재귀 함수의 스택 크키가 한정되어 있을 수 있기 때문

