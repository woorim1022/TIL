# 코딩 테스트를 위한 파이썬 문법 정리

> 이것이 코딩 테스트다 책 내용 정리

## 자료형

#### 실수형

* e 다음에 오는 수는 10의 지수부
  * ex) 1e9 는 10의 9제곱
  * 사용 예) 최단 경로로 가능한 최대 값이 10억 미만 이라면 무한(INF)를 표현할 때 10억을 이용할 수 있다.
* 소수점 값을 비교하는 작업이 필요한 문제는 round()  사용
* 나누기 연산자(/) 를 실수형으로 처리
* 몫 연산자(//), 나머지 연산자(%)

#### 리스트

* 배열 기능

* 연결 리스트 자료구조  -> append(), remove() 등의 메서드 지원

* c++의 STL vector와 유사

* 초기화 방법

  ```python
  # 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화
  n = 10
  a = [0]*n
  print(a)				
  # [0,0,0,0,0,0,0,0,0,0]
  ```

* 리스트의 인덱싱과 슬라이딩

  * 인덱싱 : 인덱스 값을 입력하여 리스트의 특정한 원소에 접근하는 것

    * 양의 정수, 음의 정수(거꾸로 탐색, -1부터) 모두 사용 가능

  * 슬라이싱 : 리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때 사용

    ```python
    a[1:4] # a의 두 번째 원소부터 네 번째 원소까지의 모든 데이터를 갖는 리스트
    ```

* 리스트 컴프리헨션  : 리스트 초기화 방법 중 하나,  대괄호([])안에 조건문과 반복문을 넣는 방식

  ```python
  # 0부터 19까지의 수 중에서 홀수만 포함하는 리스트
  array = [i for i in range(20) if i % 2 == 1]
  
  # 1 부터 9까지의 수의 제곱 값을 포함하는 리스트
  array = [i * i for i in range(1,10)]
  
  # N * M 크기의 2차원 리스트 초기화
  n = 3
  m = 4
  array = [[0] * m for _ in range(n)]
  ```

  * 언더바(_)의 역할 : 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 사용
  * 특정 크기의 2차원 리스트를 초기화할 때는 반드시 리스트 컴프리헨션을 이용해야 한다. 

* 함수

  * 변수명.append()  : 리스트에 원소 하나 삽입할 때 사용
  * 변수명.sort() : 기본 정렬 기능으로 오름차순으로 정렬
  * 변수명.reverse() : 리스트의 원소의 순서를 모두 뒤집어 놓는다
  * 변수명.insert(삽입할 위치 인덱스,삽입할 값) : 특정한 인덱스 위치에 원소를 삽입할 때 사용
  * 변수명.count(특정 값) : 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용
  * 변수명.remove(특정 값) : 특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러 개면 하나만 제거한다
    * insert(), remove() 함수 사용 주의
      * 시간 복잡도가 O(N) 이기 때문에 남발하면 '시간 초과' 로 테스트를 통과하지 못할 수 있음!
    * append() 함수의 시간 복잡도 : O(1)

#### 문자열

* '+' 연산자로 문자열 합칠 수 있음
* 문자열 변수 * 양의 정수 -> 문자열의 그 양의 정수 값만큼 더해진다
* 내부적으로 리스트와 같이 처리된다. (인덱싱/슬라이싱 이용 가능)

#### 튜플

* 리스트와 차이점
  * 한 번 선언된 값을 변경할 수 없다
  * 소괄호() 사용한다
* 리스트에 비해 상대적으로 공간 효율적
* 각 원소의 성질이 서로 다를 때 사용
  * ex) 다익스트라 최단 경로 알고리즘에서는 '비용'과 '노드 번호'라는 서로 다른 성질의 데이터를 (비용, 노드번호)의 형태로 함께 튜플로 묶어서 관리하는 것이 관례

#### 사전 자료형

* 키, 값 쌍을 데이터로 가지는 자료형

* 변경 불가능한 데이터를 키로 사용 가능

* 내부적으로 해시 테이블을 이용 -> 데이터의 검색 및 수정 O(1)의 시간에 처리 가능

* '원소 in 사전' 형태로 사전 자료형에 특정한 원소가 있는지 검사

  ```python
  data = dict()
  data['사과'] = 'Apple'
  data['바나나'] = 'Banana'
  
  if '사과' in data:
      print('"사과"를 키로 가지는 데이터가 존재합니다')
  ```

*  함수
  * 변수명.keys() : 키 데이터만 뽑아서 리스트로 이용
  * 변수명.values() : 값 데이터만을 뽑아서 리스트로 이용

#### 집합 자료형

* 특징
  * 중복 허용하지 않는다
  * 순서가 없다(정렬되어 출력) -> 인덱싱을 통해 자료형의 값을 얻을 수 없다
* 집합 자료형의 연산
  * 교집합 &
  * 합집합 |
  * 차칩합 - 
* 함수
  * 변수명.add(값)
  * 변수명.update() : 여러 개의 값을 한꺼번에 추가 

## 조건문 

* in, not in 연산자



## 반복문



## 함수

* 인자를 넘겨줄 때 파라미터의 변수를 직접 지정해서 값을 넣을 수 있다

  ```python
  add(a = 3, b = 7)
  ```

* 함수 밖의 데이터를 변경해야 하는 경우 함수에서 global 키워드 이용

  ```python
  def func():
      global a
  ```

* 람다 표현식 

  ```python
  def add(a,b):
      return a+b
  
  # 일반적인 add() 메서드 사용
  print(add(3,7))
  
  # 람다 표현식으로 구현한 add()메서드
  print((lambda a, b: a + b)(3, 7)
  ```



## 입출력

* input() : 한 줄의 문자열을 입력받도록 해준다.

* ***입력받은 문자열을 띄어쓰기로 구분하여 각각 정수 자료형의 데이터로 저장하는 코드***

  **매우매우매우매우매우매우 중요 반드시 외우자아ㅏㅏㅏㅏㅏㅏㅏ**

  ```python
  #  map을 이용하여 해당 리스트의 모든 원소에 int()를 적용한다.
  #  그 결과를 list()로 다시 바꿈으로써 입력받은 문자열을 띄어쓰기로 구분하여 각각 숫자 자료형으로 저장
  
  list(map(int, input().split))
  
  # 문제에서 첫째 줄에 n, m, k가 공백으로 구분되어 입력된다는 내용이 명시되어 있다고 가정
  # n, m, k를 공백으로 구분하여 입력
  n, m, k = map(int, input().split())
  print(n, m, k)   # 3, 5, 7
  ```

  

* 입력의 개수가 많은 경우 -> 속도 느린 input() 대신 sys.stdin.readline() 사용

  ```python
  import sys
  
  # 문자열 입력받기
  data = sys.stdin.readLine().rstrip()
  ```

* print() : 각 변수를 콤마(,) 로 구분하여 매개변수로 넣어 출력할 수 있음

  ```python
  print(a,b)
  ```

  * 출력 이후에 줄 바꿈 수행

  * 문자열과 수를 함께 출력할 때 단순히 + 연산자 이용하면 오류 발생

  * 해결

    * 출력하고자 하는 변수 데이터를 문자열로 바꿔줌

    * 각 자료형을 콤마(,)를 기준으로 구분하여 출력

      ```python
      print('정답은' + str(answer) + '입니다.')
      print('정답은', str(answer), '입니다')
      ```



## 주요 라이브러리의 문법과 유의점

#### 표준 라이브러리 

* 특정한 프로그래밍 언어에서 자주 사용되는 표준 소스코드를 미리 구현해 놓은 라이브러리

* 코딩테스트에서는 대부분 표준 라이브러러 사용을 허용

  [파이썬 표준 라이브러리 공식 문서](https://docs.python.org/ko/3/library/index.html)

#### 코딩 테스트를 위해 반드시 알아야 하는 라이브러리

* 내장 함수: print(), input() 과 같은 기본 입출력 기능부터 sorted()와 같은 정렬 기능을 포함하고 있는 기본 내장 라이브러리

  * print(), input(), sum(), min(), max(), eval(), sorted()

* itertools : 파이썬에서 반복되는 형태의 데이터를 처리하는 기능을 제공하는 라이브러리. 순열과 조합 라이브러리를 제공한다.

  * permutations() : 리스트와 같은 iterable 객체에서 r 개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)을 계산해준다.

    ```python
    from itertools import permutations
    
    data = ['A', 'B', 'C'] # 데이터 준비
    
    result = list(permutations(data,3)) # 모든 순열 구하기
    ```

  * combinations() : 순서를 고려하지 않고 나열하는 모든 경우(조합)

    ```python
    from itertools import combinations
    
    data = ['A', 'B', 'C']
    result = list(combinations(data, 2))
    
    print(result)
    ```

  * product() : permutations()와 같지만 원소를 중복하여 뽑는다

    

* heapq: 힙(Heap) 기능을 제공하는 라이브러리. 우선순위 큐 기능을 구현하기 위해 사용

  * 파이썬의 힙은 최소 힙 으로 구성되어 있기 때문에 단순히 원소를 힙에 전부 넣었다가 빼는 것만으로도 시간 복잡도 O(NlogN)에 오름차순 정렬이 완료된다

  * heapq.heappush() : 힙에 원소를 삽입

  * heapq.heqppop() : 힙에서 원소를 꺼냄

  * 파이썬에서는 최대 힙을 제공하지 않는다. 따라서 heqpq 라이브러리를 이용하여 최대 힙을 구현해야 할 때는 원소의 부호를 임시로 변경하는 방식을 사용. 힙에 원소를 삽입하기 전에 잠시 부호를 반대로 바꾸었다가, 힙에서 원소를 꺼낸 뒤에 다시 원소의 부호를 바꾸면 된다.

    ```python
    import heapq
    
    def heapsort(iterable):
        h = []
        result = []
        # 모든 원소를 차례대로 힙에 삽입
        for value in iterable:
            heapq.heappush(h, -value)
        # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
        for i in range(len(h))
        	result.append(-heapq.heappop(h))
        return result
    ```

    

* bisect: 이진 탐색(Binary Search) 기능을 제공하는 라이브러리

  * 파이썬에서는 이진 탐색을 쉽게 구현할 수 있도록 bisect 라이브러리 제공
  * '정렬된 배열'에서 특정한 원소를 찾아야 할 때 매우 효과적으로 사용된다.
  * bisect_left(a, x) : 정렬된 순서를 유지하면서 리스트 a에 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드
  * bisect_right(a, x) : 정렬된 순서를 유지하도록 리스트 a에 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드

* collections: 덱(deque), 카운터(counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리

  * 덱(deque)
    * 파이썬에서는 덱(deque)를 사용해 큐를 구현한다
    * 인덱싱, 슬라이싱 사용 불가 
    * 연속적으로 나열된 데이터의 시작 부분이나 끝부분에 데이터를 삽입하거나 삭제할 때 매우 효과적으로 사용
    * 스택이나 큐의 기능을 모두 포함
    * popleft() : 첫번째 원소 제거
    * pop() : 마지막 원소 제거
    * appendleft(x) : 첫 번째 인덱스에 원소 x를 삽입
    * append(x) : 마지막 인덱스에 원소를 삽입
  * Counter 
    * 등장 횟수를 세는 기능

*  math

  * factorial(x)
  * sqrt(x)
  * gcd(a, b) 최대공약수