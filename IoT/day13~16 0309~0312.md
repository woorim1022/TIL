# day13~16 0309~0312

#### 안드로이드 개발 환경설정

### jdk : 자바를 개발할 수 있는 툴

* 환경설정
  1. path : 실행명령어가 있는 폴더를 등록
  2. JAVA_HOME : 설치폴더



### 코틀린 : IntelliJ idea 를 사용해 개발

* 문법
  * 기본문법
  * 함수
  * 제어구문
    * if, for, while, do-while, when
  * 객체지향프로그래밍
    * 개요, 생성자, 상속, 패키지나 모듈
  * 오버로딩, 오버라이딩
  * 추상클래스, 인터페이스
  * 코틀린에서 지원하는 클래스들
  * 컬렉션
    * 배열의 단점은 보완해서 만들어진 데이터를 관리하는 객체
    * List
      * 배열과 유사, 순서가 있다
    * Map
      * key, value로 구성된 데이터를 관리하는 구조
    * Set
      * 집합, 
    * 불변과 가변을 모두 지원한다.
  * 예외처리

#### 객체지향 프로그래밍(oop)

* 클래스 작성방법

  

* 클래스의 구성요소

  * 멤버변수

  * 메소드

  * 생성자

    * 객체가 생성되면 init -> 생성자 순으로 호출

    * 클래스의 객체를 생성할 때 자동으로 실행되는 특별한 메소드

    * 객체가 생성될 때 실행하고 싶은 코드가 있는 경우 정의

      => 멤버변수의 값을 초기화

    * 생성자는 오버로딩이 가능

      * 매개변수 개수나 데이터 타입을 다르게 해서 여러 개 정의해서 사용 가능

    * 클래스를 정의할 때 주생성자(기본생성자)를 정의할 수 있다.

      class 클래스명 constructor(매개변수 list..){

      }

      or

    * 주생성자(기본생성자)로 정의하는 경우 constructor키워드를 생략할 수 있다.

      class 클래스명(매개변수 list..){

      }

  * init 블럭

    * 객체가 생성될 때 자동으로 실행되는 블럭
    * 블럭으로 만들어야 하기 때문에 외부에서 전달받은 값으로 초기화할 수 없음		
    * constructor와의 차이
      * 어떤 생성자를 실행하더라도 공통적으로 실행하고 싶은 코드는 init으로 빼서 작성한다 	
      * 객체가 생성될 때 자동으로 처리해야 하는 동작이 있으면 구현





* OOP 특성

  * 캡슐화

  * 상속성

    * 모든 클래스에 공통(중복)으로 정의해야하는 구성 요소를 하나의 클래스에 정의한 후 사용할 수 있도록 지원하는 기능

    * 상속하는 클래스 -> 부모클래스, 상위클래스, super클래스

    * 상속받는 클래스 -> 자식클래스, 하위클래스, sub클래스

    * 문법

      * 상위클래스

        open class 클래스명{

        ​	//open 키워드 사용하면 상속이 가능한 클래스가 됨

        }

      * 하위클래스

        class 클래스명:상위클래스명(){

        ​	//상위클래스를 상속받은 클래스가 됨

        }

    * 상속관계에서 생성자, 메소드의 사용

      * super

    * 부모의 멤버변수, 메소드호출, 생성자호출방법

    * 오버라이딩(overriding)

      * 오버로딩과는 다른 개념
        * 오버로딩 : 매개변수 개수, 타입을 다르게 해 똑같은 이름의 함수를 여러개 정의하는것
      * 상속관계에서 부모 클래스가 갖고 있는 메소드를 자식 클래스에서 재정의 하는 것 
      * 부모의 오버라이딩 메소드와 매개변수 갯수, 타입, 순서 모두 동일해야 한다. 즉, 메소드 선언부가 부모클래스와 동일
      * 부모클래스의 메소드가 오버라이딩된 경우 메소드를 호출하면 부모클래스의 메소드가 실행되지 않고 오버라이딩된 메소드가 호출된다.

      [형식]

      오버라이딩 할 부모의 메소드는 open 선언

      부모의 메소드를 오버라이딩 하기 위해서 오버라이딩 할 때 메소드 선언부에 override라는 modifier를 추가

    <img src="C:\Users\test\Desktop\TIL\IoT\캡처15.PNG" alt="캡처15" style="zoom:40%;" />

  * 다형성

    * 추상클래스, 인터페이스, 형변환, 오버라이딩, 상속이 모두 적용되어야 한다.

    * 형변환

      => 형변환은 참조변수의 타입을 변경하는 것을 의미

      => 참조형에서의 형변환은 상속관계에서만 가능

      => 스마트캐스팅

      ​	: 내부조건이 만족하면 자동으로 형이 변환되는 것

      ​	(부모타입의 변수 = 자식객체)

      <img src="C:\Users\test\Desktop\TIL\IoT\캡처17.PNG" alt="캡처17" style="zoom:60%;" />

    * 추상클래스

      => 미완성의 클래스를 의미

      => 추상메소드를 가지고 있는 클래스

      ​			: 메소드의 body가 없는 메소드	

      => 추상클래스는 추상메소드, 일반메소드 모두 정의할 수 있다.

      => 추상클래스이므로 객체생성을 할 수 없다.(미완성된 클래스이기 때문에)

      => 추상메소드를 선언하는 방법

      ```kotlin
      open abstract fun 메소드명()
      ```

      => 추상클래스는 상위클래스로 사용할 목적

    * 인터페이스

      => 목적은 추상클래스와 동일

      => 다형성의 극대화를 위해 즉, 추상메소드를 정의하는 특별한 클래스

      ​		일반메소드를 정의할 수는 있다

      => 코틀린이 다중상속을 지원하지 않는다.

      ​		객체를 다양하게 관리해야 할 때 활용

      => 클래스가 아니므로 객체생성할 수 없다

      => 인터페이스를 구현하는 클래스에서 추상메소드를 오버라이딩

      => 인터페이스는 여러 개 상속이 가능하다

      [문법]

      ```kotlin
      interface 인터페이스명{ 
          fun 추상메소드()   //인터페이스는 추상메소드를 정의할 목적으로 설계된 특별한 클래스이므로  						//abstract은 생략해도 된다.
      }
      ```

      

      ​	

      <img src="C:\Users\test\Desktop\TIL\IoT\캡처18.PNG" alt="캡처17" style="zoom:60%;" />



* modifier







* 패키지처리, import

  * 패키지 : 설치할 앱을 식별하는 용도(중복되면 안됨)

    * ex) com.multicampus.insa.dept.controller

      +

      ​	multicampus

      ​	+

      ​		insa

      ​		+

      ​			. . .

* 객체

  * 프로그램에서 사용될 데이터, 기능들을 관리하기 편하게 하나의 객체로 표현

    * 객체를 작성하는 방법 ->  class를 정의

      class 클래스명 {

      

      }

    * class 안에 객체를 설명하기 위한 정보, 이 객체가 처리할 수 있는 기능을 정의

      class 클래스명{

      ​	객체를 설명할 수 있는 정보 (속성, 필드, property) - 멤버변수

      ​	객체의 기능 - 메소드

      }



* 데이터타입

  * 기본형 : 값이 저장되어있는 자료형, 값을 저장
  * 참조형 : 포인터변수와 비슷함, 힙에 할당된 인스턴스를 참조해서 사용

  



#### 실습1

* 클래스 3개 작성하기
* kr.multicampus.kotlin.insa
* Student
  * 멤버변수 :  name, age, id
  * 생성자 : 1번방법
* Teacher
  * 멤버변수 : name, age, subject
  * 생성자: 4번방법
* Staff
  * 멤버변수 : name, age, dept
  * 각 멤버변수를 초기화할 수 있도록 Emp클래스처럼 생성자 3개 정의하고 사용
* print 메소드 공통
* 테스트 할 수 있는 파일 작성하기
  * SchoolTest.kt
    * 클래스 3개를 인스턴스화
    * 각 print메소드 호출하기
* [출력형태]
  * 이름 : 홍길동 나이: 20 학번 : 200201
  * 이름 : 홍길동 나이: 20 담당과목 : JAVA
  * 이름 : 홍길동 나이: 20 부서 : 교무과

#### 실습2

![캡처14](C:\Users\test\Desktop\TIL\IoT\캡처14.PNG)



#### 실습3

![캡처14](C:\Users\test\Desktop\TIL\IoT\캡처16.PNG)



#### 실습4

![캡처14](C:\Users\test\Desktop\TIL\IoT\캡처19.PNG)



#### 실습5

![캡처14](C:\Users\test\Desktop\TIL\IoT\test.PNG)

1. 다음은 Dog 클래스와 Chicken 클래스의 구현에 필요한 요구사항들입니다. 
   A. 이동거리는 run 함수가 호출될 때마다 누적되어 distance 변수에 저장되고, 
       getDistance() 함수가 호출 될 때 저장된 distance 값을 반환합니다. 
   B. fly 함수는 현재의 속도 값이 2배가 되도록 하는 기능을 수행합니다. 
   C. 또한, run 함수가 호출될 때 Chicken 객체는 입력받은 시간만큼 계속 이동하지만, Dog 
       객체는 입력인자로 넘겨받은 시간의 1/2 시간 동안만을 이동합니다. (즉, 속도가 10인 
       Dog object 가 1시간 동안 이동한 거리는 5가 되며, 속도가 3인 Chicken object가 1시간 
      동안 이동한 거리는 3이 됩니다.) 

2. 클래스 및 인터페이스를 작성해 주십시오. 
   A. Animal 추상 클래스를 작성하십시오. 
   B. Cheatable 인터페이스를 작성하십시오. 
   C. Animal 추상클래스를 상속받은 Dog 클래스를 작성하십시오. 
   D. Animal 추상클래스를 상속받고 Cheatable 인터페이스를 구현한 Chicken 클래스를 작성하
   십시오. 
   (참고: distance의 계산 시 이동거리=속도X시간 이므로 distance = speed X hours 등식을 사
   용하여 계산하면 됩니다.) 

3. 아래에 제시된 시나리오와 출력결과를 참조하여, AnimalTest 클래스를 완성하십시오.  
   A. 템플릿 코드에 선언된 dog 변수에 속도가 8인 Dog Object를 하나 생성하여 저장합니다. 
   B. 템플릿 코드에 선언된 chicken 변수에 속도가 3인 Chicken Object를 하나 생성하여 저장
   합니다. 
   C. 템플릿 코드에 선언된 cheatableChicken 변수에 속도가 5인 Chicken Object를 하나 생성
   하여 저장합니다. 
   D. 위에서 생성한 Chicken Object가 Cheatable 타입이면 fly 함수를 호출합니다. 단, 
   Cheatable타입인 객체만 호출할 수 있습니다.
   E. 3시간 동안 매 시간마다 각 객체들의 이동거리 정보가 아래와 같이 출력되도록 합니다. 
    화면 출력(AnimalTest 실행):

   1시간 후
   개의 이동거리=4.0
   닭의 이동거리=3.0
   날으는 닭의 이동거리=10.0

   2시간 후
   개의 이동거리=8.0
   닭의 이동거리=6.0
   날으는 닭의 이동거리=20.0

   3시간 후
   개의 이동거리=12.0
   닭의 이동거리=9.0
   날으는 닭의 이동거리=30.0







### 안드로이드 스튜디오 

* IntelliJ 에 안드로이드를 개발할 수 있도록 기능을 추가 

